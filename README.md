# GraphAlgorithms

This Scala project implements a simple graph library that emphasizes functional programming principles. It includes:

- **Graph Representation:**  
  The graph is modeled as an immutable `Map[String, List[(String, Int)]]`, where each key is a vertex and each value is a list of weighted edges.

- **Graph Generation (`makeGraph`):**  
  A random, strongly-connected directed graph is generated by first creating a cycle (to ensure connectivity) and then adding extra edges until a specified count is reached. Edge weights are assigned randomly.

- **Dijkstra's Algorithm & Shortest Path:**  
  Dijkstra's algorithm is implemented to compute the shortest path from a source to all vertices. A helper function reconstructs the actual path from a predecessor map.  
  *Tradeoffs:*
    - A mutable priority queue is used for performance in the inner loop of Dijkstra's algorithm. This is a pragmatic choice that isolates mutability to a small, well-defined scope while keeping the overall design functional.

- **Graph Distance Properties:**  
  Functions to compute the **eccentricity** (maximum shortest-path distance from a vertex), **radius** (minimum eccentricity), and **diameter** (maximum eccentricity) of the graph reuse the Dijkstra-based shortest path logic.
  *Tradeoffs:*
    - These calculations traverse the graph from every vertex. While not optimal for very large graphs, this approach is clear, maintainable, and sufficient for our purposes.

- **Testing:**  
  A comprehensive suite of tests (using ScalaTest) validates:
    - The correctness of graph generation (including connectivity and absence of self-loops).
    - The accuracy of shortest path computation.
    - The correct calculation of eccentricity, radius, and diameter.

## Functional Programming Principles

- **Immutability:**  
  The core data structures (the graph itself) are immutable. Any local mutability (e.g., in Dijkstra's algorithm) significantly improves performance tailored to the JVM's memory management characteristics and is encapsulated and does not leak into the public API.

- **Pure Functions:**  
  Functions that compute shortest paths, eccentricity, radius, and diameter are pure and side-effect free, making them easier to reason about and test.

- **Modularity:**  
  Each function in the project is designed to perform a single, well-defined task. This modularity promotes reusability and clarity.

## Running the Project

### Using sbt

1. **Run Tests:**
   ```bash
   sbt test


## Dockerizing the Project

We use the [sbtscala/scala-sbt](https://hub.docker.com/r/sbtscala/scala-sbt) images to build our application.  
These images follow a tag format of `<JDK version>_<sbt version>_<Scala version>`. In this project, we use:
- **JDK:** Eclipse Temurin
- **sbt:** **1.10.7**
- **Scala:** 2.13.16

Thus, we reference the image tag:  
`eclipse-temurin_1.10.7_2.13.16`

### Dockerfile Overview

1. **Build Stage:**  
   We use the `sbtscala/scala-sbt:eclipse-temurin_1.10.7_2.13.16` image to compile our project and create a fat JAR using the sbt-assembly plugin.  
   The sbt-assembly plugin bundles all dependencies into a single executable JAR.

2. **Runtime Stage:**  
   We copy the built JAR into a slim runtime image based on `eclipse-temurin:11-jre`.  
   *Note:* The Alpine variant (`eclipse-temurin:11-jre-alpine`) caused issues on our platform, so we use the standard JRE image instead.

### Building and Running the Docker Container

1. **Build the Docker image:**  
   In your projectâ€™s root directory (where the Dockerfile is located), run:
   ```bash
   docker build -t audience-republic .